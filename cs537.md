## Processes
- High level goal:
  - Give each running program the impression it is acting alone
- What changes while a program runs?
  - I/O
    - Files are included
  - CPU
    - registers
  - Memory

## Sharing the CPU
- Time sharing
  - Mechanisms
    - Direct execution
      - Process gets the entire CPU until termination
      - OS cleans up everything afterwards
      - Problems:
        - Security - Giving a process hw access is dangerous
        - Efficiency - Process might do slow IO stuff which bottlenecks the CPU
        - Process could run forever
    - Limited Direct execution
      - Direct execution but CPU supports privilege levels
      - Applications runs in user mode - can only execute certain instructions
      - OS runs in kernel mode - can execute all instructions
      - Switching between modes:
        - Trap - Enters kernel mode from user mode via system call. Privileged operation is executed
        - Timer interrupts
          - Set up by OS at boot
          - Interrupts the CPU every few milliseconds
          - Scheduler might be run on interrupts
        - Threads
          - Lightweight processes
          - Each process can have multiple threads
        - 
## Memory management
- ### Base and Bounds
  - Each process gets a base and a bounds in physical memory. Virtual addresses start from base.
  - Exception thrown by hardware on out of bounds access
    - oftentimes OS kills process and frees memory
  - OS manages list of free memory
  - OS sets base and bounds for new processes based on this free list
  - OS needs to save/restore base and bounds registers when processes switch
  - Limitations
    - Limited address space
    - Inflexible (inefficient)
- ### Segmentation 
  - Many base/bounds pairs per CPU
  - Can fit each section (code, heap, stack, etc) into the most efficient place
  - 